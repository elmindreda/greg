/* An OpenGL extension loader generated by GREG
 * Copyright Â© Camilla Berglund <dreda@dreda.org>
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would
 *    be appreciated but is not required.
 *
 * 2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 * 3. This notice may not be removed or altered from any source
 *    distribution.
 */

/* Parts of this file are reproduced from the OpenGL XML specification.
 * Copyright (c) 2013 The Khronos Group Inc.
 */

#ifndef _greg_h_
#define _greg_h_

/* GREG replaces gl.h and glext.h */
#define __gl_h_
#define __GL_H__
#define __glext_h_
#define __GLEXT_H__
#define __gltypes_h_

/* Standardize on _WIN32 as the Windows macro */
#if !defined(_WIN32) && (defined(__WIN32__) || defined(WIN32))
 #define _WIN32
#endif /* _WIN32 */

/* Define GLAPIENTRY if not already defined */
#if !defined(GLAPIENTRY)
 #if defined(_WIN32)
  #define GLAPIENTRY __stdcall
 #else
  #define GLAPIENTRY
 #endif
#endif /* GLAPIENTRY */

#if defined(GREG_STATIC)
 #define GREGDEF static
#else
 #define GREGDEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* @API_NAME@ version macros */
@VER_MACROS@
/* @API_NAME@ extension macros */
@EXT_MACROS@
/* @API_NAME@ version booleans */
@VER_DECLARATIONS@
/* @API_NAME@ extension booleans */
@EXT_DECLARATIONS@
/* @API_NAME@ types */
@TYPE_TYPEDEFS@
/* @API_NAME@ enumeration values */
@ENUM_DEFINITIONS@
/* @API_NAME@ function typedefs */
@CMD_TYPEDEFS@
/* @API_NAME@ function pointers */
@CMD_DECLARATIONS@
/* @API_NAME@ macros */
@CMD_MACROS@

/* Initializes the library
 */
GREGDEF int gregInit(void);

#ifdef __cplusplus
}
#endif

#endif /* _greg_h_ */

#ifdef GREG_IMPLEMENTATION

#include <string.h>
#include <stdio.h>

#if defined(GREG_USE_EGL)
 #include <EGL/egl.h>
#elif defined(GREG_USE_GLFW3)
 #include <GLFW/glfw3.h>
#elif defined(GREG_USE_SDL2)
 #include <SDL/SDL.h>
#elif defined(_WIN32)
 #include <windows.h>
#elif defined(__linux__)
 #include <GL/glx.h>
#elif defined(__APPLE__)
 #include <CoreFoundation/CoreFoundation.h>
 #include <OpenGL/OpenGL.h>
#endif

typedef void (*GREGproc)(void);

static struct
{
    int major;
    int minor;

#if defined(GREG_USE_EGL)
#elif defined(GREG_USE_GLFW3)
#elif defined(GREG_USE_SDL2)
#elif defined(_WIN32)
    struct
    {
        HINSTANCE instance;
    } wgl;
#elif defined(__APPLE__)
    struct
    {
        void* framework;
    } nsgl;
#endif

} _greg;

/* @API_NAME@ version booleans */
@VER_DEFINITIONS@
/* @API_NAME@ extension booleans */
@EXT_DEFINITIONS@
/* @API_NAME@ function pointers */
@CMD_DEFINITIONS@

/* Checks whether an @API_NAME@ or context is current
 */
static GLboolean gregHasContext(void)
{
#if defined(GREG_USE_EGL)
    return eglGetCurrentContext() != EGL_NO_CONTEXT;
#elif defined(GREG_USE_GLFW3)
    return glfwGetCurrentContext() != NULL;
#elif defined(GREG_USE_SDL2)
    return SDL_GL_GetCurrentContext() != NULL;
#elif defined(_WIN32)
    return wglGetCurrentContext() != NULL;
#elif defined(__linux__)
    return glXGetCurrentContext() != NULL;
#elif defined(__APPLE__)
    return CGLGetCurrentContext() != NULL;
#endif
}

/* Loads the @API_NAME@ library for function pointer discovery
 */
static GLboolean gregLoadLibrary(void)
{
#if defined(GREG_USE_EGL)
#elif defined(GREG_USE_GLFW3)
#elif defined(GREG_USE_SDL2)
    if (SDL_GL_LoadLibrary(NULL) != 0)
        return GL_FALSE;
#elif defined(_WIN32)
    _greg.wgl.instance = LoadLibraryA("opengl32.dll");
    if (!_greg.wgl.instance)
        return GL_FALSE;
#elif defined(__linux__)
#elif defined(__APPLE__)
    _greg.nsgl.framework = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.opengl"));
    if (!_greg.nsgl.framework)
        return GL_FALSE;
#endif

    return GL_TRUE;
}

/* Frees the loaded @API_NAME@ library
 */
static void gregFreeLibrary(void)
{
#if defined(GREG_USE_EGL)
#elif defined(GREG_USE_GLFW3)
#elif defined(GREG_USE_SDL2)
    SDL_GL_UnloadLibrary();
#elif defined(_WIN32)
    if (_greg.wgl.instance)
        FreeLibrary(_greg.wgl.instance);
#elif defined(__linux__)
#elif defined(__APPLE__)
    if (_greg.nsgl.framework)
        CFRelease(_greg.nsgl.framework);
#endif
}

/* Returns the address of the requested @API_NAME@ function
 */
static GREGproc gregGetProcAddress(const char* name)
{
    GREGproc proc;

#if defined(GREG_USE_EGL)
    proc = (GREGproc) eglGetProcAddress(name);
#elif defined(GREG_USE_GLFW3)
    proc = (GREGproc) glfwGetProcAddress(name);
#elif defined(GREG_USE_SDL2)
    proc = (GREGproc) SDL_GL_GetProcAddress(name);
#elif defined(_WIN32)
    proc = (GREGproc) wglGetProcAddress(name);
    if (!proc)
        proc = (GREGproc) GetProcAddress(_greg.wgl.instance, name);
#elif defined(__linux__)
    proc = (GREGproc) glXGetProcAddress((const GLubyte*) name);
#elif defined(__APPLE__)
    CFStringRef native = CFStringCreateWithCString(kCFAllocatorDefault, name, kCFStringEncodingASCII);
    proc = (GREGproc) CFBundleGetFunctionPointerForName(_greg.nsgl.framework, native);
    CFRelease(native);
#endif

    return proc;
}

/* Checks whether an extension string contains a specific extension
 */
static GLboolean gregStringInExtensionString(const char* string,
                                             const char* extensions)
{
    const char* start = extensions;

    for (;;)
    {
        const char* end;
        const char* where = strstr(start, string);
        if (!where)
            return GL_FALSE;

        end = where + strlen(string);
        if (where == start || *(where - 1) == ' ')
        {
            if (*end == ' ' || *end == '\0')
                return GL_TRUE;
        }

        start = end;
    }
}

/* Parses version numbers from the @API_NAME@ version string
 */
static GLboolean gregParseVersionString(void)
{
    int i;
    const char* version;
    const char* prefixes[] =
    {
        "OpenGL ES-CM ",
        "OpenGL ES-CL ",
        "OpenGL ES ",
        NULL
    };

    if (!glGetString)
        return GL_FALSE;

    version = (const char*) glGetString(GL_VERSION);
    if (!version)
        return GL_FALSE;

    for (i = 0;  prefixes[i];  i++)
    {
        const size_t length = strlen(prefixes[i]);
        if (strncmp(version, prefixes[i], length) == 0)
        {
            version += length;
            break;
        }
    }

#if defined(_MSC_VER)
    if (!sscanf_s(version, "%d.%d", &_greg.major, &_greg.minor))
        return GL_FALSE;
#else
    if (!sscanf(version, "%d.%d", &_greg.major, &_greg.minor))
        return GL_FALSE;
#endif

    return GL_TRUE;
}

/* Checks whether the specified @API_NAME@ version is supported
 */
static GLboolean gregVersionSupported(int major, int minor)
{
    return major > _greg.major || (major == _greg.major && minor >= _greg.minor);
}

/* Checks whether the specified @API_NAME@ extension is supported
 */
static GLboolean gregExtensionSupported(const char* name)
{
    const char* e;

#if defined(GL_VERSION_3_0) || defined(GL_ES_VERSION_3_0)
    if (_greg.major >= 3)
    {
        GLint i, count;

        if (!glGetIntegerv || !glGetStringi)
            return GL_FALSE;

        glGetIntegerv(GL_NUM_EXTENSIONS, &count);

        for (i = 0;  i < count;  i++)
        {
            e = (const char*) glGetStringi(GL_EXTENSIONS, i);
            if (!e)
                return GL_FALSE;

            if (strcmp(e, name) == 0)
                return GL_TRUE;
        }

        return GL_FALSE;
    }
#endif

    if (!glGetString)
        return GL_FALSE;

    e = (const char*) glGetString(GL_EXTENSIONS);
    if (!e)
        return GL_FALSE;

    return gregStringInExtensionString(name, e);
}

GREGDEF int gregInit(void)
{
    memset(&_greg, 0, sizeof(_greg));

    if (!gregHasContext() || !gregLoadLibrary())
    {
        gregFreeLibrary();
        return GL_FALSE;
    }

    /* Load supported @API_NAME@ functions */
@CMD_LOADERS@

    if (!gregParseVersionString())
    {
        gregFreeLibrary();
        return GL_FALSE;
    }

    /* Check supported @API_NAME@ context versions */
@VER_LOADERS@
    /* Check supported @API_NAME@ extensions */
@EXT_LOADERS@

    gregFreeLibrary();
    return GL_TRUE;
}

#endif /*GREG_IMPLEMENTATION*/
