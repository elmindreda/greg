/* GREG — オープンジーエルエクステンションジェネレータ
 * Copyright © Camilla Berglund <dreda@dreda.org>
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would
 *    be appreciated but is not required.
 *
 * 2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 * 3. This notice may not be removed or altered from any source
 *    distribution.
 */

#include <greg.h>

#include <string.h>
#include <stdio.h>

#if defined(_WIN32)
  #include <windows.h>
#elif defined(__linux__)
  #include <GL/glx.h>
#elif defined(__APPLE__)
  #include <CoreFoundation/CoreFoundation.h>
  #include <OpenGL/OpenGL.h>
#endif

typedef void (*GREGglproc)(void);

static struct
{
  int major;
  int minor;

#if defined(_WIN32)
  struct
  {
    HINSTANCE instance;
  } wgl;
#elif defined(__APPLE__)
  struct
  {
    void* framework;
  } nsgl;
#endif

} _greg;

@VER_DEFINITIONS@

@EXT_DEFINITIONS@

@CMD_DEFINITIONS@

static GLboolean gregLoadLibrary(void)
{
#if defined(_WIN32)

  _greg.wgl.instance = LoadLibraryA("opengl32.dll");
  if (!_greg.wgl.instance)
    return GL_FALSE;

  if (!wglGetCurrentContext())
    return GL_FALSE;

#elif defined(__linux__)

  if (!glXGetCurrentContext())
    return GL_FALSE;

#elif defined(__APPLE__)

  _greg.nsgl.framework =
    CFBundleGetBundleWithIdentifier(CFSTR("com.apple.opengl"));
  if (!_greg.nsgl.framework)
    return GL_FALSE;

  if (!CGLGetCurrentContext())
    return GL_FALSE;

#endif

  return GL_TRUE;
}

static void gregFreeLibrary(void)
{
#if defined(_WIN32)
  if (_greg.wgl.instance)
    FreeLibrary(_greg.wgl.instance);
#elif defined(__APPLE__)
  if (_greg.nsgl.framework)
    CFRelease(_greg.nsgl.framework);
#endif
}

static GREGglproc gregGetProcAddress(const char* name)
{
  GREGglproc proc;

#if defined(_WIN32)
  proc = (GREGglproc) wglGetProcAddress(name);
  if (!proc)
    proc = (GREGglproc) GetProcAddress(_greg.wgl.instance, name);
#elif defined(__linux__)
  proc = (GREGglproc) glXGetProcAddress((const GLubyte*) name);
#elif defined(__APPLE__)
  CFStringRef native = CFStringCreateWithCString(kCFAllocatorDefault,
                                                 name,
                                                 kCFStringEncodingASCII);
  proc = (GREGglproc) CFBundleGetFunctionPointerForName(_greg.nsgl.framework,
                                                        native);
  CFRelease(native);
#endif

  return proc;
}

static GLboolean gregStringInExtensionString(const char* string,
                                             const char* extensions)
{
  const char* start = extensions;

  for (;;)
  {
    const char* end;
    const char* where = strstr(start, string);
    if (!where)
      return GL_FALSE;

    end = where + strlen(string);
    if (where == start || *(where - 1) == ' ')
    {
      if (*end == ' ' || *end == '\0')
        return GL_TRUE;
    }

    start = end;
  }
}

static GLboolean gregValidContext(void)
{
  int i;
  const char* version;
  const char* prefixes[] =
  {
    "OpenGL ES-CM ",
    "OpenGL ES-CL ",
    "OpenGL ES ",
    NULL
  };

  if (!glGetString)
    return GL_FALSE;

  version = (const char*) glGetString(GL_VERSION);
  if (!version)
    return GL_FALSE;

  for (i = 0;  prefixes[i];  i++)
  {
    const size_t length = strlen(prefixes[i]);
    if (strncmp(version, prefixes[i], length) == 0)
    {
      version += length;
      break;
    }
  }

  if (!sscanf(version, "%d.%d", &_greg.major, &_greg.minor))
    return GL_FALSE;

  return GL_TRUE;
}

static GLboolean gregVersionSupported(int major, int minor)
{
  return major > _greg.major || (major == _greg.major && minor >= _greg.minor);
}

static GLboolean gregExtensionSupported(const char* name)
{
#if defined(GL_VERSION_3_0)
  if (_greg.major >= 3)
  {
    GLint i, count;

    if (!glGetIntegerv || !glGetStringi)
      return GL_FALSE;

    glGetIntegerv(GL_NUM_EXTENSIONS, &count);

    for (i = 0;  i < count;  i++)
    {
      const char* en = (const char*) glGetStringi(GL_EXTENSIONS, i);
      if (!en)
        return GL_FALSE;

      if (strcmp(en, name) == 0)
        return GL_TRUE;
    }

    return GL_FALSE;
  }
#endif /*GL_VERSION_3_0*/

  if (!glGetString)
    return GL_FALSE;

  const char* extensions = (const char*) glGetString(GL_EXTENSIONS);
  if (!extensions)
    return GL_FALSE;

  return gregStringInExtensionString(name, extensions);
}

int gregInit(void)
{
  memset(&_greg, 0, sizeof(_greg));

  if (!gregLoadLibrary())
  {
    gregFreeLibrary();
    return GL_FALSE;
  }

@CMD_LOADERS@

  if (!gregValidContext())
  {
    gregFreeLibrary();
    return GL_FALSE;
  }

@VER_LOADERS@

@EXT_LOADERS@

  gregFreeLibrary();
  return GL_TRUE;
}

