/* GREG — オープンジーエルエクステンションジェネレータ
 * Copyright © Camilla Berglund <dreda@dreda.org>
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would
 *    be appreciated but is not required.
 *
 * 2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 * 3. This notice may not be removed or altered from any source
 *    distribution.
 */

#include <greg.h>

#include <string.h>
#include <stdio.h>

#if defined(_WIN32)

#include <windows.h>
typedef HGLRC (WINAPI* PFNWGLGETCURRENTCONTEXTPROC)(void);
typedef PROC (WINAPI* PFNWGLGETPROCADDRESSPROC)(LPCSTR);

#elif defined(__linux__)

#include <dlfcn.h>
#include <GL/glx.h>
typedef GLXContext (*PFNGLXGETCURRENTCONTEXTPROC)(void);
typedef void (*(*PFNGLXGETPROCADDRESSPROC)(const GLubyte*))(void);

#endif

typedef void (*GREGglproc)(void);

static struct
{
  int major;
  int minor;

#if defined(_WIN32)
  struct
  {
    HINSTANCE instance;
    PFNWGLGETCURRENTCONTEXTPROC GetCurrentContext;
    PFNWGLGETPROCADDRESSPROC GetProcAddress;
  } wgl;
#elif defined(__linux__)
  struct
  {
    void* library;
    PFNGLXGETCURRENTCONTEXTPROC GetCurrentContext;
    PFNGLXGETPROCADDRESSPROC GetProcAddress;
  } glx;
#endif

} _greg;

@CMD_DEFINITIONS@

static GLboolean gregLoadLibrary(void)
{
#if defined(_WIN32)

  _greg.wgl.instance = LoadLibraryA("opengl32.dll");
  if (!_greg.wgl.instance)
    return GL_FALSE;

  _greg.wgl.GetCurrentContext = (PFNWGLGETCURRENTCONTEXTPROC)
    GetProcAddress(_greg.wgl.instance, "wglGetCurrentContext");
  _greg.wgl.GetProcAddress = (PFNWGLGETPROCADDRESSPROC)
    GetProcAddress(_greg.wgl.instance, "wglGetProcAddress");

  if (!_greg.wgl.GetCurrentContext())
    return GL_FALSE;

#elif defined(__linux__)

  _greg.glx.library = dlopen("libGL.so", RTLD_LAZY | RTLD_GLOBAL);
  if (!_greg.glx.library)
    return GL_FALSE;

  _greg.glx.GetCurrentContext = (PFNGLXGETCURRENTCONTEXTPROC)
    dlsym(_greg.glx.library, "glXGetCurrentContext");
  _greg.glx.GetProcAddress = (PFNGLXGETPROCADDRESSPROC)
    dlsym(_greg.glx.library, "glXGetProcAddress");

  if (!_greg.glx.GetCurrentContext())
    return GL_FALSE;

#endif

  return GL_TRUE;
}

static void gregFreeLibrary(void)
{
#if defined(_WIN32)
  if (_greg.wgl.instance)
    FreeLibrary(_greg.wgl.instance);
#elif defined(__linux__)
  if (_greg.glx.library)
    dlclose(_greg.glx.library);
#endif
}

static GREGglproc gregGetProcAddress(const char* name)
{
  GREGglproc proc;

#if defined(_WIN32)
  proc = (GREGglproc) _greg.wgl.GetProcAddress(name);
  if (!proc)
    proc = (GREGglproc) GetProcAddress(_greg.wgl.instance, name);
#elif defined(__linux__)
  proc = (GREGglproc) glXGetProcAddress((const GLubyte*) name);
#endif

  return proc;
}

static GLboolean gregStringInExtensionString(const char* string,
                                             const char* extensions)
{
  const char* start = extensions;

  for (;;)
  {
    const char* end;
    const char* where = strstr(start, string);
    if (!where)
      return GL_FALSE;

    end = where + strlen(string);
    if (where == start || *(where - 1) == ' ')
    {
      if (*end == ' ' || *end == '\0')
        return GL_TRUE;
    }

    start = end;
  }
}

static GLboolean gregValidContext(void)
{
  int i;
  const char* version;
  const char* prefixes[] =
  {
    "OpenGL ES-CM ",
    "OpenGL ES-CL ",
    "OpenGL ES ",
    NULL
  };

  if (!glGetString)
    return GL_FALSE;

  version = (const char*) glGetString(GL_VERSION);
  if (!version)
    return GL_FALSE;

  for (i = 0;  prefixes[i];  i++)
  {
    const size_t length = strlen(prefixes[i]);
    if (strncmp(version, prefixes[i], length) == 0)
    {
      version += length;
      break;
    }
  }

  if (!sscanf(version, "%d.%d", &_greg.major, &_greg.minor))
    return GL_FALSE;

  return GL_TRUE;
}

static GLboolean gregExtensionSupported(const char* name)
{
#if defined(GL_VERSION_3_0)
  if (_greg.major >= 3)
  {
    GLint i, count;

    if (!glGetIntegerv || !glGetStringi)
      return GL_FALSE;

    glGetIntegerv(GL_NUM_EXTENSIONS, &count);

    for (i = 0;  i < count;  i++)
    {
      const char* en = (const char*) glGetStringi(GL_EXTENSIONS, i);
      if (!en)
        return GL_FALSE;

      if (strcmp(en, name) == 0)
        return GL_TRUE;
    }

    return GL_FALSE;
  }
#endif /*GL_VERSION_3_0*/

  if (!glGetString)
    return GL_FALSE;

  const char* extensions = (const char*) glGetString(GL_EXTENSIONS);
  if (!extensions)
    return GL_FALSE;

  return gregStringInExtensionString(name, extensions);
}

int gregInit(void)
{
  memset(&_greg, 0, sizeof(_greg));

  if (!gregLoadLibrary())
  {
    gregFreeLibrary();
    return GL_FALSE;
  }

@CMD_LOADERS@

  if (!gregValidContext())
  {
    gregFreeLibrary();
    return GL_FALSE;
  }

  gregFreeLibrary();
  return GL_TRUE;
}

